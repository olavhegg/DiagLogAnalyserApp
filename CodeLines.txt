
### File: C:\Users\OlavHeggelund\Documents\DiagLogAnalyserApp\DiagLogAnalyserApp\.gitignore ###
logs
results

--------------------

### File: C:\Users\OlavHeggelund\Documents\DiagLogAnalyserApp\DiagLogAnalyserApp\CodeLines.txt ###

### File: C:\Users\OlavHeggelund\Documents\DiagLogAnalyserApp\DiagLogAnalyserApp\.gitignore ###
logs
results

--------------------

### File: C:\Users\OlavHeggelund\Documents\DiagLogAnalyserApp\DiagLogAnalyserApp\CodeLines.txt ###

--------------------

### File: C:\Users\OlavHeggelund\Documents\DiagLogAnalyserApp\DiagLogAnalyserApp\collectcode.ps1 ###
# PowerShell Script to Collect Code Lines from a Directory and Subdirectories

# Define parameters
$Directory = Get-Location
$OutputFile = "CodeLines.txt"

# Ensure output file is empty or create it
Set-Content -Path $OutputFile -Value ""  

# Get all files recursively, excluding 'results' and 'logs' directories
$files = Get-ChildItem -Path $Directory -Recurse -File | Where-Object {
    ($_.FullName -notlike "*\results\*") -and ($_.FullName -notlike "*\logs\*")
}

foreach ($file in $files) {
    # Write file name as a header
    Add-Content -Path $OutputFile -Value "### File: $($file.FullName) ###"
    
    # Read file content and write each line
    $lines = Get-Content -Path $file.FullName
    foreach ($line in $lines) {
        Add-Content -Path $OutputFile -Value $line
    }
    
    # Add a separator for clarity
    Add-Content -Path $OutputFile -Value "`n--------------------`n"
}

Write-Host "Code lines collected and stored in $OutputFile"

--------------------

### File: C:\Users\OlavHeggelund\Documents\DiagLogAnalyserApp\DiagLogAnalyserApp\Launch-DiagLogAnalyzer.ps1 ###
# DiagLog Analyzer - Main Launcher Script

# Add required assemblies first
Add-Type -AssemblyName System.Windows.Forms
Add-Type -AssemblyName System.Drawing

# Get the root path and ensure it's using Windows path format
$script:RootPath = $PSScriptRoot
if (-not $script:RootPath) {
    $script:RootPath = Split-Path -Parent $MyInvocation.MyCommand.Path
}
$script:RootPath = $script:RootPath.Replace('/', '\')

# Create required directories if they don't exist
$requiredPaths = @(
    (Join-Path $script:RootPath "logs"),
    (Join-Path $script:RootPath "results"),
    (Join-Path $script:RootPath "temp")
)

foreach ($path in $requiredPaths) {
    if (-not (Test-Path $path)) {
        New-Item -Path $path -ItemType Directory -Force | Out-Null
    }
}

# Module import order is important - define dependencies
$moduleOrder = @(
    "src\Config\Settings.psm1",        # Load first - no dependencies
    "src\Utils\Logging.psm1",          # Depends on Settings
    "src\Utils\FileSystem.psm1",       # Depends on Logging
    "src\Core\FileSearch.psm1",        # Depends on FileSystem
    "src\Core\CabExtractor.psm1",      # Depends on FileSystem
    "src\Core\Analyzer.psm1",          # Depends on all above
    "src\GUI\Controls.psm1",           # Depends on Settings
    "src\GUI\MainForm.psm1"            # Depends on all above
)

# Import modules in correct order
foreach ($module in $moduleOrder) {
    $modulePath = Join-Path -Path $script:RootPath -ChildPath $module
    Write-Host "Attempting to load module: $modulePath"
    
    if (Test-Path $modulePath) {
        try {
            Import-Module $modulePath -Force -ErrorAction Stop
            Write-Host "Successfully loaded module: $module" -ForegroundColor Green
        }
        catch {
            Write-Error "Failed to load module $module : $_"
            exit 1
        }
    }
    else {
        Write-Error "Required module not found: $modulePath"
        exit 1
    }
}

# Initialize settings and logging
try {
    # First initialize Settings module
    if (Get-Command Initialize-DLASettings -ErrorAction SilentlyContinue) {
        Initialize-DLASettings
        Write-Host "Settings initialized successfully" -ForegroundColor Green
    }
    else {
        throw "Initialize-DLASettings function not found"
    }
    
    # Then initialize Logging module
    if (Get-Command Initialize-DLALogging -ErrorAction SilentlyContinue) {
        Initialize-DLALogging
        Write-DLALog -Message "Starting DiagLog Analyzer" -Level INFO
        Write-Host "Logging initialized successfully" -ForegroundColor Green
    }
    else {
        throw "Initialize-DLALogging function not found"
    }
    
    # Launch the main form
    if (Get-Command Show-MainForm -ErrorAction SilentlyContinue) {
        Write-Host "Launching main form..." -ForegroundColor Green
        try {
            $result = Show-MainForm
            if (-not $result) {
                throw "Show-MainForm returned an error status"
            }
        }
        catch {
            throw "Error in Show-MainForm: $_"
        }
    }
    else {
        throw "Show-MainForm function not found"
    }
}
catch {
    $errorMsg = "Failed to start DiagLog Analyzer: $_"
    
    # Try to log the error if logging is available
    if (Get-Command Write-DLALog -ErrorAction SilentlyContinue) {
        Write-DLALog -Message $errorMsg -Level ERROR
    }
    else {
        Write-Error $errorMsg
    }
    
    # Show UI error message
    [System.Windows.Forms.MessageBox]::Show($errorMsg, "Error", 
        [System.Windows.Forms.MessageBoxButtons]::OK, 
        [System.Windows.Forms.MessageBoxIcon]::Error)
}

--------------------

### File: C:\Users\OlavHeggelund\Documents\DiagLogAnalyserApp\DiagLogAnalyserApp\README.md ###
# DiagLog Analyzer

A PowerShell-based application for analyzing Windows diagnostic log files, with a focus on handling complex diagnostic data capture structures such as those found in MDM diagnostics.

## Features

- **Folder Structure Analysis**: Quickly scan and understand complex diagnostic log directory structures
- **Intelligent CAB Extraction**: Automatically extract CAB files while preserving their context and relationship to original files
- **Smart Content Search**: Search across multiple files with filtering by file type, pattern matching, and context display
- **Visual Reporting**: Generate interactive HTML reports of analysis findings and search results
- **Intuitive GUI Interface**: Easy-to-use interface that guides users through the analysis process

## Requirements

- Windows 10/11
- PowerShell 5.1 or later
- .NET Framework 4.7.2 or later

## Installation

No installation required. Simply clone or download this repository and run the Launch-DiagLogAnalyzer.ps1 script.

## Usage

1. Run Launch-DiagLogAnalyzer.ps1 to start the application
   - This script performs prerequisite checks and initializes the environment
   - It then launches the main application interface
2. Select a DiagLogs root folder to analyze
3. Choose an output folder for results
4. Use the integrated tools to analyze structure, extract CAB files, and search content

## Key Components

- **Structure Analysis**: Scan directory trees to understand file relationships and types
- **CAB Extraction**: Extract and index CAB files while maintaining references to source locations
- **Content Search**: Search across multiple file types with context-aware results
- **Reporting Engine**: Generate HTML reports with interactive elements

## Application Architecture

The application uses a modular architecture:

- **Launch-DiagLogAnalyzer.ps1**: Entry point that handles prerequisites and initializes the environment
- **Start-Analysis.ps1**: Main application script that loads all modules and launches the GUI
- **src/Config/**: Configuration management modules
- **src/Core/**: Core analysis functionality modules
- **src/GUI/**: User interface components
- **src/Utils/**: Utility functions and helpers

## Development

### Building a Standalone Application

To build a standalone executable:

1. Install the PS2EXE module:
   ```powershell
   Install-Module -Name ps2exe
   ```

2. Use the following command:
   ```powershell
   Invoke-ps2exe -InputFile "Launch-DiagLogAnalyzer.ps1" -OutputFile "DiagLogAnalyzer.exe" -NoConsole
   ```

### File Structure

```
DiagLogAnalyzerApp/
├── Launch-DiagLogAnalyzer.ps1    # Application launcher
├── Start-Analysis.ps1            # Main application script
├── settings.json                 # Settings file (auto-generated)
├── README.md                     # Documentation
├── logs/                         # Log directory (auto-created)
├── results/                      # Results directory (auto-created)
└── src/
    ├── Config/
    │   └── Settings.ps1          # Settings management
    ├── Core/
    │   ├── Analyzer.ps1          # Core analysis functionality
    │   ├── CabExtractor.ps1      # CAB extraction utilities
    │   └── FileSearch.ps1        # File search utilities
    ├── GUI/
    │   ├── MainForm.ps1          # Main application form
    │   └── Controls.ps1          # Custom controls
    └── Utils/
        ├── FileSystem.ps1        # File system utilities
        ├── Logging.ps1           # Logging utilities
        └── Reporting.ps1         # Reporting utilities
```

## Troubleshooting

If you encounter issues:

1. Check the log files in the `logs` directory
2. Verify settings.json is not corrupted
3. Try running the script with administrator privileges
4. Use the Test-Settings.ps1 script to test configuration

## License

MIT License

## Acknowledgments

- YSoft SafeQ diagnostic tools which inspired this application's approach to log analysis

--------------------

### File: C:\Users\OlavHeggelund\Documents\DiagLogAnalyserApp\DiagLogAnalyserApp\settings.json ###
{
  "AppName": "DiagLog Analyzer",
  "Version": "1.0.0",
  "DefaultOutputPath": "results",
  "LogPath": "logs",
  "MaxFileSizeForTextSearch": 52428800,
  "DefaultFileTypesToSearch": [
    ".log",
    ".txt",
    ".xml",
    ".html",
    ".json",
    ".csv"
  ],
  "ExtractCabsAutomatically": false,
  "SkipExistingCabExtracts": true,
  "MainFormWidth": 900,
  "MainFormHeight": 700,
  "ResultsFontFamily": "Consolas",
  "ResultsFontSize": 9,
  "LogLevelName": "INFO"
}

--------------------

### File: C:\Users\OlavHeggelund\Documents\DiagLogAnalyserApp\DiagLogAnalyserApp\test-Launch.ps1 ###
# DiagLog Analyzer - Simple Launcher

# Get root path
$rootPath = $PSScriptRoot
if (-not $rootPath) {
    $rootPath = Split-Path -Parent $MyInvocation.MyCommand.Path
}

# Import just the MainForm module
$mainFormPath = Join-Path -Path $rootPath -ChildPath "src\GUI\MainForm.psm1"
Write-Host "Attempting to load module: $mainFormPath"

try {
    # Force import the module
    Import-Module $mainFormPath -Force -ErrorAction Stop
    Write-Host "Successfully loaded MainForm module" -ForegroundColor Green
    
    # Show the form
    Write-Host "Launching main form..." -ForegroundColor Green
    $result = Show-MainForm
    Write-Host "Form result: $result" -ForegroundColor Green
}
catch {
    $errorMsg = "Error: $_"
    Write-Host $errorMsg -ForegroundColor Red
    [System.Windows.Forms.MessageBox]::Show($errorMsg, "Error", 
        [System.Windows.Forms.MessageBoxButtons]::OK, 
        [System.Windows.Forms.MessageBoxIcon]::Error)
}

--------------------

### File: C:\Users\OlavHeggelund\Documents\DiagLogAnalyserApp\DiagLogAnalyserApp\src\Config\Settings.psm1 ###
# DiagLog Analyzer - Settings Management
# This module handles application settings and configuration

# Default settings file path
$script:SettingsPath = Join-Path -Path $PSScriptRoot -ChildPath "..\..\settings.json"

# Global variable to store settings
$Global:AppSettings = $null

$script:Config = @{
    LogPath = Join-Path $PSScriptRoot "../../logs"
    MaxLogSize = 10MB
    DefaultSearchPath = [Environment]::GetFolderPath('MyDocuments')
    DiagnosticSettings = @{
        DefaultTimeout = 3600  # 1 hour in seconds
        MaxConcurrentDiags = 3
        WorkingDirectory = Join-Path $PSScriptRoot "../../temp"
        ResultsDirectory = Join-Path $PSScriptRoot "../../results"
        AutoCleanup = $true
        CleanupAge = 7  # Days
    }
}

# Global settings
$script:Settings = @{
    LogPath = Join-Path $PSScriptRoot "..\..\logs\diaganalyzer.log"
    ResultsPath = Join-Path $PSScriptRoot "..\..\results"
    TempPath = Join-Path $PSScriptRoot "..\..\temp"
    LogLevel = "DEBUG"  # DEBUG, INFO, WARN, ERROR
}

function Get-AppSettings {
    return $script:Config
}

function Initialize-Settings {
    # Check if settings file exists
    if (Test-Path -Path $script:SettingsPath) {
        try {
            # Load settings from JSON file
            $Global:AppSettings = Get-Content -Path $script:SettingsPath -Raw | ConvertFrom-Json
            Write-Verbose "Settings loaded from $script:SettingsPath"
            
            # Validate settings and apply defaults where needed
            Validate-Settings
        }
        catch {
            Write-Warning "Failed to load settings: $_"
            # Create default settings
            Create-DefaultSettings
        }
    }
    else {
        # Create default settings
        Create-DefaultSettings
    }
    
    # Ensure directories exist
    $outputPath = Get-AppSetting -Name "DefaultOutputPath"
    $logPath = Get-AppSetting -Name "LogPath"
    
    $paths = @($outputPath, $logPath)
    foreach ($path in $paths) {
        if (-not [string]::IsNullOrEmpty($path) -and -not (Test-Path -Path $path)) {
            New-Item -Path $path -ItemType Directory -Force | Out-Null
        }
    }
}

function Validate-Settings {
    # This function ensures all required settings have valid values
    # Check for missing properties and add them with default values
    
    # Define default settings map
    $defaultSettings = @{
        "AppName" = "DiagLog Analyzer"
        "Version" = "1.0.0"
        "DefaultOutputPath" = Join-Path -Path $PSScriptRoot -ChildPath "..\..\results"
        "LogPath" = Join-Path -Path $PSScriptRoot -ChildPath "..\..\logs"
        "MaxFileSizeForTextSearch" = 50MB
        "DefaultFileTypesToSearch" = @(".log", ".txt", ".xml", ".html", ".json", ".csv")
        "ExtractCabsAutomatically" = $false
        "SkipExistingCabExtracts" = $true
        "MainFormWidth" = 900
        "MainFormHeight" = 700
        "ResultsFontFamily" = "Consolas"
        "ResultsFontSize" = 9
        "LogLevelName" = "INFO"
    }
    
    # Validate and repair each setting
    foreach ($key in $defaultSettings.Keys) {
        # Check if property exists
        if (-not $Global:AppSettings.PSObject.Properties.Name -contains $key) {
            # Property doesn't exist, add it with default value
            $Global:AppSettings | Add-Member -NotePropertyName $key -NotePropertyValue $defaultSettings[$key]
            Write-Verbose "Added missing setting '$key' with default value: $($defaultSettings[$key])"
        }
        else {
            # Property exists, check if value is valid
            $currentValue = $Global:AppSettings.$key
            
            # Handle numerical values validation
            if ($key -in @("MainFormWidth", "MainFormHeight", "ResultsFontSize", "MaxFileSizeForTextSearch")) {
                # Ensure numerical values are valid (greater than 0)
                if ($null -eq $currentValue -or 
                    (-not [string]::IsNullOrEmpty($currentValue) -and -not [double]::TryParse($currentValue.ToString(), [ref]$null)) -or 
                    $currentValue -le 0) {
                    
                    # Replace invalid value with default
                    $Global:AppSettings.$key = $defaultSettings[$key]
                    Write-Verbose "Replaced invalid value for '$key' with default: $($defaultSettings[$key])"
                }
            }
            # Handle array values validation
            elseif ($key -eq "DefaultFileTypesToSearch") {
                if ($null -eq $currentValue -or -not ($currentValue -is [array])) {
                    $Global:AppSettings.$key = $defaultSettings[$key]
                    Write-Verbose "Replaced invalid value for '$key' with default array"
                }
            }
            # Handle string values validation
            elseif ($key -in @("AppName", "Version", "ResultsFontFamily", "LogLevelName")) {
                if ([string]::IsNullOrEmpty($currentValue)) {
                    $Global:AppSettings.$key = $defaultSettings[$key]
                    Write-Verbose "Replaced empty string for '$key' with default: $($defaultSettings[$key])"
                }
            }
            # Handle path validations
            elseif ($key -in @("DefaultOutputPath", "LogPath")) {
                if ([string]::IsNullOrEmpty($currentValue)) {
                    $Global:AppSettings.$key = $defaultSettings[$key]
                    Write-Verbose "Replaced empty path for '$key' with default: $($defaultSettings[$key])"
                }
            }
            # Handle boolean validations
            elseif ($key -in @("ExtractCabsAutomatically", "SkipExistingCabExtracts")) {
                if ($null -eq $currentValue) {
                    $Global:AppSettings.$key = $defaultSettings[$key]
                    Write-Verbose "Replaced null boolean for '$key' with default: $($defaultSettings[$key])"
                }
            }
        }
    }
    
    # Add diagnostic settings validation
    $diagSettings = @{
        "DiagTimeout" = 3600
        "MaxConcurrentDiags" = 3
        "DiagWorkingPath" = Join-Path -Path $PSScriptRoot -ChildPath "..\..\temp"
        "DiagResultsPath" = Join-Path -Path $PSScriptRoot -ChildPath "..\..\results"
        "AutoCleanupDiags" = $true
        "DiagCleanupAgeDays" = 7
        "DiagDefaultParameters" = @{
            SkipVersionCheck = $false
            ForceElevated = $true
            IncludeSystemLogs = $true
        }
    }
    
    foreach ($key in $diagSettings.Keys) {
        if (-not $Global:AppSettings.PSObject.Properties.Name -contains $key) {
            $Global:AppSettings | Add-Member -NotePropertyName $key -NotePropertyValue $diagSettings[$key]
            Write-Verbose "Added missing diagnostic setting '$key' with default value"
        }
    }
}

function Create-DefaultSettings {
    # Default settings
    $Global:AppSettings = [PSCustomObject]@{
        AppName = "DiagLog Analyzer"
        Version = "1.0.0"
        DefaultOutputPath = Join-Path -Path $PSScriptRoot -ChildPath "..\..\results"
        LogPath = Join-Path -Path $PSScriptRoot -ChildPath "..\..\logs"
        MaxFileSizeForTextSearch = 50MB
        DefaultFileTypesToSearch = @(".log", ".txt", ".xml", ".html", ".json", ".csv")
        ExtractCabsAutomatically = $false
        SkipExistingCabExtracts = $true
        MainFormWidth = 900
        MainFormHeight = 700
        ResultsFontFamily = "Consolas"
        ResultsFontSize = 9
        LogLevelName = "INFO"
        # Add diagnostic-specific settings
        DiagTimeout = 3600
        MaxConcurrentDiags = 3
        DiagWorkingPath = Join-Path -Path $PSScriptRoot -ChildPath "..\..\temp"
        DiagResultsPath = Join-Path -Path $PSScriptRoot -ChildPath "..\..\results"
        AutoCleanupDiags = $true
        DiagCleanupAgeDays = 7
        DiagDefaultParameters = @{
            SkipVersionCheck = $false
            ForceElevated = $true
            IncludeSystemLogs = $true
        }
    }
    
    # Save default settings
    Save-AppSettings
    
    Write-Verbose "Created default settings including diagnostic configuration"
}

function Get-AppSetting {
    param (
        [Parameter(Mandatory=$true)]
        [string]$Name,
        
        [Parameter(Mandatory=$false)]
        [object]$DefaultValue = $null
    )
    
    # Ensure settings are initialized
    if ($null -eq $Global:AppSettings) {
        Initialize-Settings
    }
    
    # Get property value using reflection (works with PSCustomObject)
    if ($Global:AppSettings.PSObject.Properties.Name -contains $Name) {
        $value = $Global:AppSettings.$Name
        
        # Return default if value is null
        if ($null -eq $value -and $null -ne $DefaultValue) {
            return $DefaultValue
        }
        
        return $value
    }
    else {
        Write-Warning "Setting '$Name' not found, returning default value"
        return $DefaultValue
    }
}

function Set-AppSetting {
    param (
        [Parameter(Mandatory=$true)]
        [string]$Name,
        
        [Parameter(Mandatory=$false)]
        [AllowNull()]
        [object]$Value
    )
    
    # Ensure settings are initialized
    if ($null -eq $Global:AppSettings) {
        Initialize-Settings
    }
    
    try {
        # Check if property exists
        if ($Global:AppSettings.PSObject.Properties.Name -contains $Name) {
            # Set property via reflection
            $Global:AppSettings.$Name = $Value
        }
        else {
            # Add new property
            $Global:AppSettings | Add-Member -NotePropertyName $Name -NotePropertyValue $Value
        }
        return $true
    }
    catch {
        Write-Warning "Failed to set setting '$Name': $_"
        return $false
    }
}

function Save-AppSettings {
    try {
        # Ensure settings are initialized
        if ($null -eq $Global:AppSettings) {
            Initialize-Settings
        }
        
        # Run validation before saving
        Validate-Settings
        
        # Convert to JSON and save
        # Use Depth parameter to ensure all nested objects are properly serialized
        $jsonSettings = ConvertTo-Json -InputObject $Global:AppSettings -Depth 10 -Compress:$false
        Set-Content -Path $script:SettingsPath -Value $jsonSettings -Encoding UTF8
        
        Write-Verbose "Settings saved to $script:SettingsPath"
        return $true
    }
    catch {
        Write-Warning "Failed to save settings: $_"
        return $false
    }
}

# Create a backup of the settings file
function Backup-Settings {
    try {
        if (Test-Path -Path $script:SettingsPath) {
            $backupFolder = Join-Path -Path (Split-Path -Parent $script:SettingsPath) -ChildPath "backups"
            
            if (-not (Test-Path -Path $backupFolder)) {
                New-Item -Path $backupFolder -ItemType Directory -Force | Out-Null
            }
            
            $timestamp = Get-Date -Format "yyyyMMdd_HHmmss"
            $backupPath = Join-Path -Path $backupFolder -ChildPath "settings_$timestamp.json"
            
            Copy-Item -Path $script:SettingsPath -Destination $backupPath -Force
            Write-Verbose "Settings backed up to $backupPath"
            return $true
        }
        
        return $false
    }
    catch {
        Write-Warning "Failed to back up settings: $_"
        return $false
    }
}

# Reset settings to default
function Reset-Settings {
    try {
        # Create backup before resetting
        Backup-Settings
        
        # Create default settings
        Create-DefaultSettings
        
        Write-Verbose "Settings reset to default values"
        return $true
    }
    catch {
        Write-Warning "Failed to reset settings: $_"
        return $false
    }
}

function Initialize-DLASettings {
    Write-Host "Initializing settings..."
    # Nothing to do yet, settings are initialized when module loads
    return $true
}

function Get-DLASetting {
    param (
        [Parameter(Mandatory=$true)]
        [string]$Name
    )
    return $script:Settings[$Name]
}

# Initialize settings when the module is loaded
Initialize-Settings

Export-ModuleMember -Function Get-AppSettings, 
                            Get-AppSetting, 
                            Set-AppSetting, 
                            Initialize-Settings, 
                            Save-AppSettings, 
                            Reset-Settings,
                            Initialize-DLASettings,
                            Get-DLASetting

--------------------

### File: C:\Users\OlavHeggelund\Documents\DiagLogAnalyserApp\DiagLogAnalyserApp\src\Core\Analyzer.psm1 ###
# DiagLog Analyzer - Core Analyzer Module
# This module handles file structure analysis

# Import required modules properly
$modulePath = Split-Path -Parent $PSScriptRoot
$modulesToImport = @(
    (Join-Path -Path $modulePath -ChildPath "Utils\Logging.psm1"),
    (Join-Path -Path $modulePath -ChildPath "Utils\FileSystem.psm1")
)

foreach ($module in $modulesToImport) {
    Import-Module $module -Force
}

# Function to analyze folder structure
function Start-FolderAnalysis {
    param (
        [Parameter(Mandatory=$true)]
        [string]$FolderPath,
        
        [switch]$IncludeSubFolders = $true
    )
    
    Write-DLALog -Message "Starting folder analysis for $FolderPath" -Level INFO -Component "Analyzer"
    
    # Initialize results structure
    $analysisResults = @{
        SourcePath = $FolderPath
        AnalysisTime = Get-Date
        TotalItems = 0
        Files = 0
        Directories = 0
        TotalSize = 0
        Extensions = @{}
        FileTypes = @{}
        LargestFiles = @()
        CabFiles = @()
        DirectoryDepth = 0
    }
    
    try {
        # Get child items based on recursion option
        $itemParams = @{
            Path = $FolderPath
            Force = $true
            ErrorAction = "SilentlyContinue"
        }
        
        if ($IncludeSubFolders) {
            $itemParams.Recurse = $true
        }
        
        $allItems = Get-ChildItem @itemParams
        
        # Process items
        foreach ($item in $allItems) {
            $analysisResults.TotalItems++
            
            if ($item.PSIsContainer) {
                $analysisResults.Directories++
                
                # Calculate directory depth
                $relativePath = $item.FullName.Substring($FolderPath.Length)
                $depth = ($relativePath -replace '[^\\]').Length
                if ($depth -gt $analysisResults.DirectoryDepth) {
                    $analysisResults.DirectoryDepth = $depth
                }
            }
            else {
                $analysisResults.Files++
                $analysisResults.TotalSize += $item.Length
                
                # Process extension
                $extension = $item.Extension.ToLower()
                if ([string]::IsNullOrEmpty($extension)) {
                    $extension = "(no extension)"
                }
                
                if (-not $analysisResults.Extensions.ContainsKey($extension)) {
                    $analysisResults.Extensions[$extension] = @{
                        Count = 0
                        TotalSize = 0
                        SampleFiles = @()
                    }
                }
                
                $analysisResults.Extensions[$extension].Count++
                $analysisResults.Extensions[$extension].TotalSize += $item.Length
                
                # Keep up to 5 sample files per extension
                if ($analysisResults.Extensions[$extension].SampleFiles.Count -lt 5) {
                    $analysisResults.Extensions[$extension].SampleFiles += $item.FullName
                }
                
                # Determine file type
                $fileType = Get-FileType -FilePath $item.FullName
                
                if (-not $analysisResults.FileTypes.ContainsKey($fileType)) {
                    $analysisResults.FileTypes[$fileType] = @{
                        Count = 0
                        TotalSize = 0
                    }
                }
                
                $analysisResults.FileTypes[$fileType].Count++
                $analysisResults.FileTypes[$fileType].TotalSize += $item.Length
                
                # Track all files in the analysis
                $analysisResults.LargestFiles += [PSCustomObject]@{
                    Path = $item.FullName
                    Size = $item.Length
                    Extension = $extension
                    Type = $fileType
                }
                
                # Check if it's a CAB file
                if (Test-CabFile -FilePath $item.FullName) {
                    $analysisResults.CabFiles += [PSCustomObject]@{
                        Path = $item.FullName
                        Size = $item.Length
                        RelativePath = $item.FullName.Substring($FolderPath.Length + 1)
                        Processed = $false
                        ExtractedPath = $null
                    }
                }
            }
        }
        
        Write-DLALog -Message "Folder analysis completed: $($analysisResults.Files) files, $($analysisResults.Directories) directories" -Level INFO -Component "Analyzer"
        return $analysisResults
    }
    catch {
        Write-DLALog -Message "Error during folder analysis: $_" -Level ERROR -Component "Analyzer"
        throw $_
    }
}

# Function to get analysis summary as a string
function Get-AnalysisSummary {
    param (
        [Parameter(Mandatory=$true)]
        [hashtable]$AnalysisResults
    )
    
    $summary = @"
Analysis Summary
---------------
Source Path: $($AnalysisResults.SourcePath)
Analysis Time: $($AnalysisResults.AnalysisTime)

Total Items: $($AnalysisResults.TotalItems)
Files: $($AnalysisResults.Files)
Directories: $($AnalysisResults.Directories)
Total Size: $(Format-FileSize -SizeInBytes $AnalysisResults.TotalSize)
Directory Depth: $($AnalysisResults.DirectoryDepth)
CAB Files: $($AnalysisResults.CabFiles.Count)

File Extensions:
$(
    $AnalysisResults.Extensions.GetEnumerator() | 
    Sort-Object -Property {$_.Value.Count} -Descending | 
    ForEach-Object {
        "  $($_.Key): $($_.Value.Count) files, $(Format-FileSize -SizeInBytes $_.Value.TotalSize)"
    } | Out-String
)

File Types:
$(
    $AnalysisResults.FileTypes.GetEnumerator() | 
    Sort-Object -Property {$_.Value.Count} -Descending | 
    ForEach-Object {
        "  $($_.Key): $($_.Value.Count) files, $(Format-FileSize -SizeInBytes $_.Value.TotalSize)"
    } | Out-String
)

Largest Files:
$(
    $AnalysisResults.LargestFiles | 
    Select-Object -First 10 | 
    ForEach-Object {
        "  $(Format-FileSize -SizeInBytes $_.Size): $($_.Path)"
    } | Out-String
)
"@
    
    return $summary
}

function Start-LogAnalysis {
    param(
        [string]$LogPath
    )
    Write-DLALog -Message "Starting analysis of: $LogPath" -Level INFO
    # Add analysis logic here
}

# Export functions
Export-ModuleMember -Function Start-LogAnalysis, Start-FolderAnalysis, Get-AnalysisSummary

--------------------

### File: C:\Users\OlavHeggelund\Documents\DiagLogAnalyserApp\DiagLogAnalyserApp\src\Core\CabExtractor.psm1 ###
# DiagLog Analyzer - CAB Extractor Module
# This module handles extraction of CAB files

# Import dependencies using relative paths from module root
$modulePath = Split-Path -Parent (Split-Path -Parent $PSScriptRoot)

# Import required modules
Import-Module (Join-Path -Path $modulePath -ChildPath "src\Utils\Logging.psm1") -Force
Import-Module (Join-Path -Path $modulePath -ChildPath "src\Utils\FileSystem.psm1") -Force
Import-Module (Join-Path -Path $modulePath -ChildPath "src\Config\Settings.psm1") -Force

# Function to extract a single CAB file
function Expand-CabFile {
    param (
        [Parameter(Mandatory=$true)]
        [string]$CabFilePath,
        
        [Parameter(Mandatory=$false)]
        [string]$DestinationPath = $null,
        
        [switch]$SkipIfExists = $true,
        
        [switch]$ValidateExtraction = $true,
        
        [switch]$CleanupOnFailure = $true
    )
    
    try {
        # Verify the cab file exists and is valid
        if (-not (Test-Path -Path $CabFilePath -PathType Leaf)) {
            throw "CAB file not found or is not a file: $CabFilePath"
        }

        # Verify file extension
        if ([System.IO.Path]::GetExtension($CabFilePath) -ne '.cab') {
            throw "File is not a CAB file: $CabFilePath"
        }

        # Create destination path if not specified
        if ([string]::IsNullOrEmpty($DestinationPath)) {
            $cabFileName = [System.IO.Path]::GetFileName($CabFilePath)
            $cabDirectory = [System.IO.Path]::GetDirectoryName($CabFilePath)
            $extractFolderName = [System.IO.Path]::GetFileNameWithoutExtension($cabFileName)
            $DestinationPath = Join-Path -Path $cabDirectory -ChildPath "$extractFolderName"
        }
        
        # Get expected contents before extraction
        $expectedContents = Get-CabContents -CabFilePath $CabFilePath
        if ($null -eq $expectedContents) {
            throw "Failed to read CAB contents"
        }
        
        # Check if destination already exists
        if ((Test-Path -Path $DestinationPath) -and $SkipIfExists) {
            Write-Log -Message "Skipping CAB extraction, folder already exists: $DestinationPath" -Level INFO -Component "CabExtractor"
            return [PSCustomObject]@{
                Success = $true
                CabPath = $CabFilePath
                ExtractedPath = $DestinationPath
                Message = "Extraction skipped, folder already exists"
                Files = $expectedContents
            }
        }
        
        # Create the destination directory
        New-Item -Path $DestinationPath -ItemType Directory -Force | Out-Null
        
        Write-Log -Message "Extracting CAB file: $CabFilePath to $DestinationPath" -Level INFO -Component "CabExtractor"
        
        # Use expand.exe with better output capture
        $expandCmd = "expand.exe -F:* `"$CabFilePath`" `"$DestinationPath`""
        $output = & cmd.exe /c $expandCmd 2>&1
        $exitCode = $LASTEXITCODE
        
        if ($exitCode -eq 0) {
            if ($ValidateExtraction) {
                # Verify extracted files
                $extractedFiles = Get-ChildItem -Path $DestinationPath -Recurse -File
                $missingFiles = $expectedContents | Where-Object {
                    -not (Test-Path (Join-Path -Path $DestinationPath -ChildPath $_.Name))
                }
                
                if ($missingFiles) {
                    throw "Extraction validation failed. Missing files: $($missingFiles.Name -join ', ')"
                }
            }
            
            Write-Log -Message "CAB extraction completed successfully: $CabFilePath" -Level INFO -Component "CabExtractor"
            return [PSCustomObject]@{
                Success = $true
                CabPath = $CabFilePath
                ExtractedPath = $DestinationPath
                Message = "Extraction successful"
                Files = $expectedContents
                Output = $output
            }
        }
        else {
            throw "Expand.exe failed with exit code $exitCode. Output: $($output -join "`n")"
        }
    }
    catch {
        Write-Log -Message "Exception during CAB extraction: $_" -Level ERROR -Component "CabExtractor"
        
        # Cleanup on failure if requested
        if ($CleanupOnFailure -and (Test-Path -Path $DestinationPath)) {
            Write-Log -Message "Cleaning up failed extraction directory: $DestinationPath" -Level INFO -Component "CabExtractor"
            Remove-Item -Path $DestinationPath -Recurse -Force -ErrorAction SilentlyContinue
        }
        
        return [PSCustomObject]@{
            Success = $false
            CabPath = $CabFilePath
            ExtractedPath = $null
            Message = "Exception: $_"
            Output = $output
        }
    }
}

# Function to extract all CAB files from analysis results
function Expand-AnalysisCabFiles {
    param (
        [Parameter(Mandatory=$true)]
        [hashtable]$AnalysisResults,
        
        [switch]$SkipExisting = $true
    )
    
    $extractionResults = @()
    $extractedCount = 0
    $skippedCount = 0
    $failedCount = 0
    
    Write-Log -Message "Beginning extraction of $($AnalysisResults.CabFiles.Count) CAB files" -Level INFO -Component "CabExtractor"
    
    foreach ($cabFile in $AnalysisResults.CabFiles) {
        $extractResult = Expand-CabFile -CabFilePath $cabFile.Path -SkipIfExists:$SkipExisting
        
        # Update the cab file object with extraction results
        $cabFile.Processed = $true
        $cabFile.ExtractedPath = $extractResult.ExtractedPath
        $cabFile.ExtractionSuccess = $extractResult.Success
        $cabFile.ExtractionMessage = $extractResult.Message
        
        # Track statistics
        if ($extractResult.Success) {
            if ($extractResult.Message -like "*skipped*") {
                $skippedCount++
            }
            else {
                $extractedCount++
            }
        }
        else {
            $failedCount++
        }
        
        $extractionResults += $extractResult
    }
    
    Write-Log -Message "CAB extraction completed: $extractedCount extracted, $skippedCount skipped, $failedCount failed" -Level INFO -Component "CabExtractor"
    
    return [PSCustomObject]@{
        TotalCabs = $AnalysisResults.CabFiles.Count
        ExtractedCount = $extractedCount
        SkippedCount = $skippedCount
        FailedCount = $failedCount
        Results = $extractionResults
    }
}

# Function to get the list of files inside a CAB without extracting
function Get-CabContents {
    param (
        [Parameter(Mandatory=$true)]
        [string]$CabFilePath
    )
    
    try {
        # Verify the cab file exists
        if (-not (Test-Path -Path $CabFilePath -PathType Leaf)) {
            throw "CAB file not found or is not a file: $CabFilePath"
        }
        
        Write-Log -Message "Listing CAB file contents: $CabFilePath" -Level DEBUG -Component "CabExtractor"
        
        # Use expand.exe with -D option to list contents
        $expandCmd = "expand.exe -D `"$CabFilePath`""
        $output = & cmd.exe /c $expandCmd 2>&1
        
        if ($LASTEXITCODE -ne 0) {
            throw "Failed to list CAB contents. Exit code: $LASTEXITCODE. Output: $($output -join "`n")"
        }
        
        # Parse the output to extract file listing with improved regex
        $files = @()
        foreach ($line in $output) {
            if ($line -match '^\s*(.+?)\s+(\d+)\s*$') {
                $fileName = $matches[1].Trim()
                $fileSize = [int]$matches[2]
                
                # Skip if fileName is empty or contains only whitespace
                if ([string]::IsNullOrWhiteSpace($fileName)) {
                    continue
                }
                
                $files += [PSCustomObject]@{
                    Name = $fileName
                    Size = $fileSize
                    Path = $fileName # Full path within the CAB
                }
            }
        }
        
        return $files
    }
    catch {
        Write-Log -Message "Error listing CAB contents: $_" -Level ERROR -Component "CabExtractor"
        return $null
    }
}

--------------------

### File: C:\Users\OlavHeggelund\Documents\DiagLogAnalyserApp\DiagLogAnalyserApp\src\Core\FileSearch.psm1 ###
# DiagLog Analyzer - File Search Module
# This module handles searching through files for specific text

# Import dependencies using relative paths from module root
$modulePath = Split-Path -Parent (Split-Path -Parent $PSScriptRoot)

# Import required modules
Import-Module (Join-Path -Path $modulePath -ChildPath "src\Utils\Logging.psm1") -Force
Import-Module (Join-Path -Path $modulePath -ChildPath "src\Utils\FileSystem.psm1") -Force
Import-Module (Join-Path -Path $modulePath -ChildPath "src\Config\Settings.psm1") -Force

# Function to search for text in a single file
function Search-TextInFile {
    param (
        [Parameter(Mandatory=$true)]
        [string]$FilePath,
        
        [Parameter(Mandatory=$true)]
        [string]$SearchText,
        
        [int]$ContextLinesBefore = 2,
        
        [int]$ContextLinesAfter = 2,
        
        [switch]$CaseSensitive = $false
    )
    
    try {
        # Check if file exists
        if (-not (Test-Path -Path $FilePath)) {
            return $null
        }
        
        # Get file size and check if it's too large
        $fileInfo = Get-Item -Path $FilePath
        $maxFileSize = Get-AppSetting -Name "MaxFileSizeForTextSearch"
        
        if ($fileInfo.Length -gt $maxFileSize) {
            Write-Log -Message "Skipping large file ($($fileInfo.Length) bytes): $FilePath" -Level INFO -Component "FileSearch"
            return [PSCustomObject]@{
                FilePath = $FilePath
                Matches = @()
                MatchCount = 0
                Skipped = $true
                SkipReason = "File too large"
            }
        }
        
        # Check if it's a binary file
        $fileType = Get-FileType -FilePath $FilePath
        if ($fileType -ne "text") {
            Write-Log -Message "Skipping non-text file ($fileType): $FilePath" -Level INFO -Component "FileSearch"
            return [PSCustomObject]@{
                FilePath = $FilePath
                Matches = @()
                MatchCount = 0
                Skipped = $true
                SkipReason = "Non-text file"
            }
        }
        
        # Read file content
        $content = Get-Content -Path $FilePath -ErrorAction Stop
        
        # Prepare regex options
        $regexOptions = [System.Text.RegularExpressions.RegexOptions]::None
        if (-not $CaseSensitive) {
            $regexOptions = [System.Text.RegularExpressions.RegexOptions]::IgnoreCase
        }
        
        # Escape the search text for regex
        $searchPattern = [regex]::Escape($SearchText)
        
        # Find all matches with line numbers
        $matchingLines = @()
        $totalMatches = 0
        
        for ($i = 0; $i -lt $content.Count; $i++) {
            $line = $content[$i]
            
            if ($line -match $searchPattern) {
                $totalMatches++
                
                # Get context lines before
                $beforeLines = @()
                for ($j = [Math]::Max(0, $i - $ContextLinesBefore); $j -lt $i; $j++) {
                    $beforeLines += [PSCustomObject]@{
                        LineNumber = $j + 1
                        Text = $content[$j]
                        IsMatch = $false
                    }
                }
                
                # Current matching line
                $matchLine = [PSCustomObject]@{
                    LineNumber = $i + 1
                    Text = $line
                    IsMatch = $true
                }
                
                # Get context lines after
                $afterLines = @()
                for ($j = $i + 1; $j -lt [Math]::Min($content.Count, $i + 1 + $ContextLinesAfter); $j++) {
                    $afterLines += [PSCustomObject]@{
                        LineNumber = $j + 1
                        Text = $content[$j]
                        IsMatch = $false
                    }
                }
                
                # Create match context object
                $matchContext = [PSCustomObject]@{
                    MatchLineNumber = $i + 1
                    MatchLine = $line
                    BeforeContext = $beforeLines
                    AfterContext = $afterLines
                    AllLines = ($beforeLines + $matchLine + $afterLines)
                }
                
                $matchingLines += $matchContext
                
                # Limit results to avoid overwhelming with too many matches
                if ($matchingLines.Count -ge 100) {
                    Write-Log -Message "Reached maximum match limit (100) for file: $FilePath" -Level INFO -Component "FileSearch"
                    break
                }
            }
        }
        
        return [PSCustomObject]@{
            FilePath = $FilePath
            Matches = $matchingLines
            MatchCount = $totalMatches
            Skipped = $false
            SkipReason = $null
        }
    }
    catch {
        Write-Log -Message "Error searching file $FilePath : $_" -Level ERROR -Component "FileSearch"
        return [PSCustomObject]@{
            FilePath = $FilePath
            Matches = @()
            MatchCount = 0
            Skipped = $true
            SkipReason = "Error: $_"
        }
    }
}

# Function to search for text in multiple files
function Search-TextInFiles {
    param (
        [Parameter(Mandatory=$true)]
        [string[]]$FilePaths,
        
        [Parameter(Mandatory=$true)]
        [string]$SearchText,
        
        [string[]]$FileTypesToInclude = @(),
        
        [string[]]$FileTypesToExclude = @(),
        
        [int]$ContextLinesBefore = 2,
        
        [int]$ContextLinesAfter = 2,
        
        [switch]$CaseSensitive = $false,
        
        [switch]$IncludeSkipped = $false
    )
    
    Write-Log -Message "Searching for '$SearchText' in $($FilePaths.Count) files" -Level INFO -Component "FileSearch"
    
    $results = @()
    $fileCount = 0
    $matchCount = 0
    $skippedCount = 0
    
    foreach ($file in $FilePaths) {
        # Check file extension against inclusion/exclusion lists
        $extension = [System.IO.Path]::GetExtension($file).ToLower()
        
        if ($FileTypesToInclude.Count -gt 0 -and $extension -notin $FileTypesToInclude) {
            $skippedCount++
            continue
        }
        
        if ($FileTypesToExclude.Count -gt 0 -and $extension -in $FileTypesToExclude) {
            $skippedCount++
            continue
        }
        
        $fileCount++
        
        # Search the file
        $searchResult = Search-TextInFile -FilePath $file -SearchText $SearchText `
            -ContextLinesBefore $ContextLinesBefore -ContextLinesAfter $ContextLinesAfter `
            -CaseSensitive:$CaseSensitive
        
        if ($null -ne $searchResult) {
            if ($searchResult.Skipped) {
                $skippedCount++
                if ($IncludeSkipped) {
                    $results += $searchResult
                }
            }
            elseif ($searchResult.MatchCount -gt 0) {
                $matchCount += $searchResult.MatchCount
                $results += $searchResult
            }
        }
    }
    
    Write-Log -Message "Search completed. Found $matchCount matches in $($results.Count) files. Skipped $skippedCount files." -Level INFO -Component "FileSearch"
    
    return [PSCustomObject]@{
        SearchText = $SearchText
        TotalFiles = $FilePaths.Count
        FilesProcessed = $fileCount
        FilesWithMatches = ($results | Where-Object { -not $_.Skipped -and $_.MatchCount -gt 0 }).Count
        FilesSkipped = $skippedCount
        TotalMatches = $matchCount
        Results = $results
    }
}

# Function to search in analysis results
function Search-AnalysisResults {
    param (
        [Parameter(Mandatory=$true)]
        [hashtable]$AnalysisResults,
        
        [Parameter(Mandatory=$true)]
        [string]$SearchText,
        
        [string[]]$ExtensionsToInclude = @(),
        
        [string[]]$ExtensionsToExclude = @(),
        
        [string[]]$FileTypesToInclude = @(),
        
        [string[]]$FileTypesToExclude = @(),
        
        [int]$ContextLinesBefore = 2,
        
        [int]$ContextLinesAfter = 2,
        
        [switch]$CaseSensitive = $false,
        
        [switch]$IncludeExtractedCabs = $true
    )
    
    Write-Log -Message "Starting search in analysis results for: $SearchText" -Level INFO -Component "FileSearch"
    
    # Get all files to search
    $filesToSearch = @()
    
    # Add files from the main analysis
    $allFiles = Get-ChildItem -Path $AnalysisResults.SourcePath -Recurse -File
    
    foreach ($file in $allFiles) {
        $extension = $file.Extension.ToLower()
        
        # Apply extension filters
        if ($ExtensionsToInclude.Count -gt 0 -and $extension -notin $ExtensionsToInclude) {
            continue
        }
        
        if ($ExtensionsToExclude.Count -gt 0 -and $extension -in $ExtensionsToExclude) {
            continue
        }
        
        # Add to search list
        $filesToSearch += $file.FullName
    }
    
    # Also search in extracted CAB files if requested
    if ($IncludeExtractedCabs) {
        foreach ($cabFile in $AnalysisResults.CabFiles) {
            if ($cabFile.Processed -and $cabFile.ExtractionSuccess -and $null -ne $cabFile.ExtractedPath) {
                $extractedFiles = Get-ChildItem -Path $cabFile.ExtractedPath -Recurse -File
                
                foreach ($file in $extractedFiles) {
                    $extension = $file.Extension.ToLower()
                    
                    # Apply extension filters
                    if ($ExtensionsToInclude.Count -gt 0 -and $extension -notin $ExtensionsToInclude) {
                        continue
                    }
                    
                    if ($ExtensionsToExclude.Count -gt 0 -and $extension -in $ExtensionsToExclude) {
                        continue
                    }
                    
                    # Add to search list
                    $filesToSearch += $file.FullName
                }
            }
        }
    }
    
    Write-Log -Message "Prepared search list with $($filesToSearch.Count) files" -Level INFO -Component "FileSearch"
    
    # Execute search
    $searchResults = Search-TextInFiles -FilePaths $filesToSearch -SearchText $SearchText `
        -FileTypesToInclude $FileTypesToInclude -FileTypesToExclude $FileTypesToExclude `
        -ContextLinesBefore $ContextLinesBefore -ContextLinesAfter $ContextLinesAfter `
        -CaseSensitive:$CaseSensitive
    
    return $searchResults
}

# Function to highlight search text in a string
function Format-SearchTextHighlight {
    param (
        [Parameter(Mandatory=$true)]
        [string]$Text,
        
        [Parameter(Mandatory=$true)]
        [string]$SearchText,
        
        [switch]$CaseSensitive = $false,
        
        [string]$HighlightPrefix = "<span class='highlight'>",
        
        [string]$HighlightSuffix = "</span>"
    )
    
    if ([string]::IsNullOrEmpty($Text) -or [string]::IsNullOrEmpty($SearchText)) {
        return $Text
    }
    
    $comparisonType = if ($CaseSensitive) { [StringComparison]::Ordinal } else { [StringComparison]::OrdinalIgnoreCase }
    $pattern = [regex]::Escape($SearchText)
    
    if ($CaseSensitive) {
        return [regex]::Replace($Text, $pattern, "$HighlightPrefix`$&$HighlightSuffix")
    }
    else {
        return [regex]::Replace($Text, $pattern, "$HighlightPrefix`$&$HighlightSuffix", [System.Text.RegularExpressions.RegexOptions]::IgnoreCase)
    }
}

--------------------

### File: C:\Users\OlavHeggelund\Documents\DiagLogAnalyserApp\DiagLogAnalyserApp\src\GUI\Controls.psm1 ###
# DiagLog Analyzer - GUI Controls Module
# This module provides common GUI controls with consistent styling

# Import required assemblies
Add-Type -AssemblyName System.Windows.Forms
Add-Type -AssemblyName System.Drawing

# Import required modules
$settingsModule = Join-Path -Path $PSScriptRoot -ChildPath "..\Config\Settings.psm1"
Import-Module $settingsModule -Force

function New-DLAButton {
    param (
        [Parameter(Mandatory=$true)]
        [string]$Text,
        
        [int]$Width = 100,
        [int]$Height = 30,
        [int]$X = 0,
        [int]$Y = 0,
        
        [scriptblock]$OnClick
    )
    
    $button = New-Object System.Windows.Forms.Button
    $button.Text = $Text
    $button.Size = New-Object System.Drawing.Size($Width, $Height)
    $button.Location = New-Object System.Drawing.Point($X, $Y)
    $button.UseVisualStyleBackColor = $true
    
    if ($OnClick) {
        $button.Add_Click($OnClick)
    }
    
    return $button
}

function New-DLATextBox {
    param (
        [string]$Text = "",
        [int]$Width = 200,
        [int]$Height = 20,
        [int]$X = 0,
        [int]$Y = 0,
        [switch]$Multiline,
        [switch]$ReadOnly
    )
    
    $textBox = New-Object System.Windows.Forms.TextBox
    $textBox.Text = $Text
    $textBox.Size = New-Object System.Drawing.Size($Width, $Height)
    $textBox.Location = New-Object System.Drawing.Point($X, $Y)
    $textBox.Multiline = $Multiline
    $textBox.ReadOnly = $ReadOnly
    
    if ($Multiline) {
        $textBox.ScrollBars = "Vertical"
    }
    
    return $textBox
}

function New-DLALabel {
    param (
        [Parameter(Mandatory=$true)]
        [string]$Text,
        
        [int]$Width = 100,
        [int]$Height = 20,
        [int]$X = 0,
        [int]$Y = 0
    )
    
    $label = New-Object System.Windows.Forms.Label
    $label.Text = $Text
    $label.Size = New-Object System.Drawing.Size($Width, $Height)
    $label.Location = New-Object System.Drawing.Point($X, $Y)
    $label.AutoSize = $true
    
    return $label
}

function New-DLAProgressBar {
    param (
        [int]$Width = 200,
        [int]$Height = 20,
        [int]$X = 0,
        [int]$Y = 0,
        [int]$Minimum = 0,
        [int]$Maximum = 100
    )
    
    $progressBar = New-Object System.Windows.Forms.ProgressBar
    $progressBar.Size = New-Object System.Drawing.Size($Width, $Height)
    $progressBar.Location = New-Object System.Drawing.Point($X, $Y)
    $progressBar.Minimum = $Minimum
    $progressBar.Maximum = $Maximum
    $progressBar.Style = "Continuous"
    
    return $progressBar
}

function New-DLAListView {
    param (
        [int]$Width = 400,
        [int]$Height = 300,
        [int]$X = 0,
        [int]$Y = 0,
        [string[]]$Columns
    )
    
    $listView = New-Object System.Windows.Forms.ListView
    $listView.Size = New-Object System.Drawing.Size($Width, $Height)
    $listView.Location = New-Object System.Drawing.Point($X, $Y)
    $listView.View = [System.Windows.Forms.View]::Details
    $listView.FullRowSelect = $true
    $listView.GridLines = $true
    
    if ($Columns) {
        foreach ($col in $Columns) {
            $listView.Columns.Add($col) | Out-Null
        }
        $listView.Columns | ForEach-Object { $_.Width = ($Width - 25) / $Columns.Count }
    }
    
    return $listView
}

function Show-DLADialog {
    param (
        [Parameter(Mandatory=$true)]
        [string]$Message,
        
        [string]$Title = "DiagLog Analyzer",
        [ValidateSet("Info", "Warning", "Error", "Question")]
        [string]$Type = "Info"
    )
    
    $icon = switch ($Type) {
        "Info" { [System.Windows.Forms.MessageBoxIcon]::Information }
        "Warning" { [System.Windows.Forms.MessageBoxIcon]::Warning }
        "Error" { [System.Windows.Forms.MessageBoxIcon]::Error }
        "Question" { [System.Windows.Forms.MessageBoxIcon]::Question }
    }
    
    return [System.Windows.Forms.MessageBox]::Show($Message, $Title, 
        [System.Windows.Forms.MessageBoxButtons]::OK, $icon)
}

function New-TabControl {
    $tabControl = New-Object System.Windows.Forms.TabControl
    $tabControl.Dock = "Fill"
    $tabControl.Name = "MainTabControl"
    
    # Create and add all tabs
    $tabControl.TabPages.AddRange(@(
        (New-AnalysisTab),
        (New-SearchTab),
        (New-ResultsTab),
        (New-SettingsTab)
    ))
    
    return $tabControl
}

function New-AnalysisTab {
    $tab = New-Object System.Windows.Forms.TabPage
    $tab.Text = "Analysis"
    $tab.Name = "AnalysisTab"
    
    $panel = New-Object System.Windows.Forms.TableLayoutPanel
    $panel.Dock = "Fill"
    $panel.ColumnCount = 2
    $panel.RowCount = 3
    
    # Source folder selection
    $lblSource = New-Object System.Windows.Forms.Label
    $lblSource.Text = "Source Folder:"
    $txtSource = New-Object System.Windows.Forms.TextBox
    $txtSource.Name = "SourcePath"
    $btnBrowse = New-Object System.Windows.Forms.Button
    $btnBrowse.Text = "Browse..."
    
    # Analysis options group
    $groupOptions = New-Object System.Windows.Forms.GroupBox
    $groupOptions.Text = "Analysis Options"
    $chkRecursive = New-Object System.Windows.Forms.CheckBox
    $chkRecursive.Text = "Include Subfolders"
    $groupOptions.Controls.Add($chkRecursive)
    
    # Start button
    $btnAnalyze = New-Object System.Windows.Forms.Button
    $btnAnalyze.Text = "Start Analysis"
    $btnAnalyze.Dock = "Bottom"
    
    # Add controls to panel
    $panel.Controls.AddRange(@($lblSource, $txtSource, $btnBrowse, $groupOptions, $btnAnalyze))
    $tab.Controls.Add($panel)
    
    return $tab
}

function New-SearchTab {
    $tab = New-Object System.Windows.Forms.TabPage
    $tab.Text = "Search"
    $tab.Name = "SearchTab"
    
    $panel = New-Object System.Windows.Forms.TableLayoutPanel
    $panel.Dock = "Fill"
    
    # Search controls
    $txtSearch = New-Object System.Windows.Forms.TextBox
    $txtSearch.Name = "SearchText"
    $btnSearch = New-Object System.Windows.Forms.Button
    $btnSearch.Text = "Search"
    
    # Results grid
    $grid = New-Object System.Windows.Forms.DataGridView
    $grid.Dock = "Fill"
    $grid.AutoSizeColumnsMode = "Fill"
    
    $panel.Controls.AddRange(@($txtSearch, $btnSearch, $grid))
    $tab.Controls.Add($panel)
    
    return $tab
}

function New-ResultsTab {
    $tab = New-Object System.Windows.Forms.TabPage
    $tab.Text = "Results"
    $tab.Name = "ResultsTab"
    
    $panel = New-Object System.Windows.Forms.TableLayoutPanel
    $panel.Dock = "Fill"
    
    # Results view
    $resultsView = New-Object System.Windows.Forms.RichTextBox
    $resultsView.Dock = "Fill"
    $resultsView.ReadOnly = $true
    
    $panel.Controls.Add($resultsView)
    $tab.Controls.Add($panel)
    
    return $tab
}

function New-SettingsTab {
    $tab = New-Object System.Windows.Forms.TabPage
    $tab.Text = "Settings"
    $tab.Name = "SettingsTab"
    
    $panel = New-Object System.Windows.Forms.PropertyGrid
    $panel.Dock = "Fill"
    $tab.Controls.Add($panel)
    
    return $tab
}

function New-StatusStrip {
    $status = New-Object System.Windows.Forms.StatusStrip
    $statusLabel = New-Object System.Windows.Forms.ToolStripStatusLabel
    $statusLabel.Name = "StatusLabel"
    $statusLabel.Text = "Ready"
    $status.Items.Add($statusLabel)
    return $status
}

# Export all the control creation functions
Export-ModuleMember -Function New-DLAButton, 
                            New-DLATextBox, 
                            New-DLALabel, 
                            New-DLAProgressBar, 
                            New-DLAListView, 
                            Show-DLADialog,
                            New-TabControl,
                            New-StatusStrip

--------------------

### File: C:\Users\OlavHeggelund\Documents\DiagLogAnalyserApp\DiagLogAnalyserApp\src\GUI\cuicode.ps1 ###
# PowerShell Script to Collect Code Lines from a Directory and Subdirectories

# Define parameters
$Directory = Get-Location
$OutputFile = "CodeLines.txt"

# Ensure output file is empty or create it
Set-Content -Path $OutputFile -Value ""  

# Get all files recursively, excluding 'results' and 'logs' directories
$files = Get-ChildItem -Path $Directory -Recurse -File | Where-Object {
    ($_.FullName -notlike "*\results\*") -and ($_.FullName -notlike "*\logs\*")
}

foreach ($file in $files) {
    # Write file name as a header
    Add-Content -Path $OutputFile -Value "### File: $($file.FullName) ###"
    
    # Read file content and write each line
    $lines = Get-Content -Path $file.FullName
    foreach ($line in $lines) {
        Add-Content -Path $OutputFile -Value $line
    }
    
    # Add a separator for clarity
    Add-Content -Path $OutputFile -Value "`n--------------------`n"
}

Write-Host "Code lines collected and stored in $OutputFile"

--------------------

### File: C:\Users\OlavHeggelund\Documents\DiagLogAnalyserApp\DiagLogAnalyserApp\src\GUI\EventHandlers.ps1 ###
# Event Handlers Module

function BrowseButtonClick {
    param(
        [System.Windows.Forms.Button]$Button,
        [System.Windows.Forms.Control.ControlCollection]$Controls
    )
    
    $folderPath = Show-FolderPicker -Description "Select DiagLogs folder"
    if ($folderPath) {
        $Controls["SourcePath"].Text = $folderPath
    }
}

function Handle-AnalyzeButtonClick {
    param(
        [System.Windows.Forms.Button]$Button,
        [System.Windows.Forms.Control.ControlCollection]$Controls
    )
    
    $sourcePath = $Controls["SourcePath"].Text
    if ([string]::IsNullOrWhiteSpace($sourcePath)) {
        Show-Error "Please select a DiagLogs folder!"
        return
    }

    # Update status
    Update-Status "Analyzing folder structure..."

    # Start analysis in background
    $params = @{
        FolderPath = $sourcePath
        IncludeSubFolders = $true
    }

    Show-ProgressDialog -Title "Analysis" -Message "Analyzing folder structure..." -ScriptBlock {
        param($p)
        return Start-FolderAnalysis @p
    } -ArgumentList $params
}

function Handle-SearchButtonClick {
    param(
        [System.Windows.Forms.Button]$button,
        [hashtable]$controls
    )
    
    try {
        if ($null -eq $script:AnalysisResults) {
            Show-Error "Please analyze a folder first!"
            return
        }
        
        # ... Rest of search button click handler
    }
    catch {
        Show-Error "Error during search: $_"
    }
}

# ... Continue with other event handlers

--------------------

### File: C:\Users\OlavHeggelund\Documents\DiagLogAnalyserApp\DiagLogAnalyserApp\src\GUI\Helpers.ps1 ###
# Helper functions for GUI operations

function Set-ResultsFont {
    param([System.Windows.Forms.Control]$Control)
    try {
        $fontFamily = Get-AppSetting -Name "ResultsFontFamily" -DefaultValue "Consolas"
        $fontSize = Get-AppSetting -Name "ResultsFontSize" -DefaultValue 9
        $Control.Font = New-Object System.Drawing.Font($fontFamily, $fontSize)
    }
    catch {
        $Control.Font = New-Object System.Drawing.Font("Consolas", 9)
    }
}

function Show-Error {
    param([string]$Message, [string]$Title = "Error")
    [System.Windows.Forms.MessageBox]::Show($Message, $Title, 
        [System.Windows.Forms.MessageBoxButtons]::OK, 
        [System.Windows.Forms.MessageBoxIcon]::Error)
}

function Update-Status {
    param([string]$Message)
    $statusLabel = $script:MainForm.Controls["StatusStrip"].Items["StatusLabel"]
    if ($statusLabel) {
        $statusLabel.Text = $Message
    }
}

# ... Add more helper functions

--------------------

### File: C:\Users\OlavHeggelund\Documents\DiagLogAnalyserApp\DiagLogAnalyserApp\src\GUI\MainForm.psm1 ###
# DiagLog Analyzer - Main Form
# This file contains the main application window and UI logic

# Import assemblies
Add-Type -AssemblyName System.Windows.Forms
Add-Type -AssemblyName System.Drawing

# Global variables
$script:MainForm = $null
$script:AnalysisResults = $null

function Show-MainForm {
    try {
        # Create form
        $form = New-Object System.Windows.Forms.Form
        $form.Text = "DiagLog Analyzer"
        $form.Size = New-Object System.Drawing.Size(900, 700)
        $form.StartPosition = "CenterScreen"
        
        # Store reference
        $script:MainForm = $form
        
        # Main layout
        $mainLayout = New-Object System.Windows.Forms.TableLayoutPanel
        $mainLayout.Dock = "Fill"
        $mainLayout.RowCount = 2
        $mainLayout.ColumnCount = 1
        $mainLayout.ColumnStyles.Add((New-Object System.Windows.Forms.ColumnStyle([System.Windows.Forms.SizeType]::Percent, 100)))
        $mainLayout.RowStyles.Add((New-Object System.Windows.Forms.RowStyle([System.Windows.Forms.SizeType]::Percent, 100)))
        $mainLayout.RowStyles.Add((New-Object System.Windows.Forms.RowStyle([System.Windows.Forms.SizeType]::Absolute, 25)))
        
        # Tab control
        $tabControl = New-Object System.Windows.Forms.TabControl
        $tabControl.Dock = "Fill"
        $tabControl.Name = "MainTabControl"
        
        # Analysis tab
        $analysisTab = New-Object System.Windows.Forms.TabPage
        $analysisTab.Text = "Analysis"
        $analysisTab.Name = "AnalysisTab"
        
        # Add some basic controls to Analysis tab
        $lblSource = New-Object System.Windows.Forms.Label
        $lblSource.Text = "Source Folder:"
        $lblSource.Location = New-Object System.Drawing.Point(10, 15)
        $lblSource.AutoSize = $true
        
        $txtSource = New-Object System.Windows.Forms.TextBox
        $txtSource.Location = New-Object System.Drawing.Point(120, 12)
        $txtSource.Width = 400
        $txtSource.Name = "SourcePath"
        
        $btnBrowse = New-Object System.Windows.Forms.Button
        $btnBrowse.Text = "Browse..."
        $btnBrowse.Location = New-Object System.Drawing.Point(530, 10)
        $btnBrowse.Width = 80
        $btnBrowse.Add_Click({
            $folderBrowser = New-Object System.Windows.Forms.FolderBrowserDialog
            $folderBrowser.Description = "Select DiagLogs folder to analyze"
            if ($folderBrowser.ShowDialog() -eq 'OK') {
                $txtSource.Text = $folderBrowser.SelectedPath
            }
        })
        
        # Add controls to analysis tab
        $analysisTab.Controls.AddRange(@($lblSource, $txtSource, $btnBrowse))
        
        # Search tab
        $searchTab = New-Object System.Windows.Forms.TabPage
        $searchTab.Text = "Search"
        $searchTab.Name = "SearchTab"
        
        # Add tabs to tab control
        $tabControl.TabPages.AddRange(@($analysisTab, $searchTab))
        
        # Status strip
        $statusStrip = New-Object System.Windows.Forms.StatusStrip
        $statusLabel = New-Object System.Windows.Forms.ToolStripStatusLabel
        $statusLabel.Name = "StatusLabel"
        $statusLabel.Text = "Ready"
        $statusStrip.Items.Add($statusLabel)
        
        # Add controls to main layout
        $mainLayout.Controls.Add($tabControl, 0, 0)
        $mainLayout.Controls.Add($statusStrip, 0, 1)
        
        # Add main layout to form
        $form.Controls.Add($mainLayout)
        
        # Show the form
        Write-Host "About to show form dialog"
        [void]$form.ShowDialog()
        
        # Return success
        return $true
    }
    catch {
        # Log the error with type information for debugging
        $errorType = $_.Exception.GetType().FullName
        $errorMsg = "Error showing main form ($errorType): $_"
        Write-Host $errorMsg -ForegroundColor Red
        
        # Re-throw for caller
        throw $errorMsg
    }
}

# Helper function to update the status strip
function Update-Status {
    param([string]$Message)
    
    if ($null -ne $script:MainForm) {
        $statusStrip = $script:MainForm.Controls | Where-Object { $_ -is [System.Windows.Forms.StatusStrip] }
        if ($statusStrip) {
            $statusLabel = $statusStrip.Items["StatusLabel"]
            if ($statusLabel) {
                $statusLabel.Text = $Message
            }
        }
    }
}

# Export functions
Export-ModuleMember -Function Show-MainForm, Update-Status

--------------------

### File: C:\Users\OlavHeggelund\Documents\DiagLogAnalyserApp\DiagLogAnalyserApp\src\GUI\MainWindow.ps1 ###
# Import dependencies
. (Join-Path -Path $PSScriptRoot -ChildPath "Controls.ps1")
. (Join-Path -Path $PSScriptRoot -ChildPath "EventHandlers.ps1")
. (Join-Path -Path $PSScriptRoot -ChildPath "TabControls.ps1")
. (Join-Path -Path $PSScriptRoot -ChildPath "Panels.ps1")
. (Join-Path -Path $PSScriptRoot -ChildPath "Helpers.ps1")

# Global variables for application state
$script:MainForm = $null
$script:AnalysisResults = $null

function Initialize-MainWindow {
    param(
        [string]$PowerShellPath = "$PSHOME\powershell.exe"
    )
    
    $form = New-Object System.Windows.Forms.Form
    $form.Text = "DiagLog Analyzer"
    $form.Size = New-Object System.Drawing.Size(
        (Get-AppSetting -Name "MainFormWidth"),
        (Get-AppSetting -Name "MainFormHeight")
    )
    $form.StartPosition = "CenterScreen"
    
    # Store reference to main form
    $script:MainForm = $form
    
    # Set icon if available
    if ($PowerShellPath -and (Test-Path $PowerShellPath)) {
        try {
            $form.Icon = [System.Drawing.Icon]::ExtractAssociatedIcon($PowerShellPath)
        }
        catch {
            Write-Log -Message "Could not load icon: $_" -Level WARNING -Component "GUI"
        }
    }
    
    # Add main tab control
    $tabControl = New-TabControl
    $form.Controls.Add($tabControl)
    
    # Add status strip
    $statusStrip = New-StatusStrip
    $form.Controls.Add($statusStrip)
    
    # Add form closing event
    $form.Add_FormClosing({
        param($sender, $e)
        Save-AppSettings
        Write-Log -Message "Application closing" -Level INFO -Component "GUI"
    })
    
    # Add form resize end event to save window size
    $form.Add_ResizeEnd({
        Set-AppSetting -Name "MainFormWidth" -Value $form.Size.Width
        Set-AppSetting -Name "MainFormHeight" -Value $form.Size.Height
    })
    
    return $form
}

function Show-MainWindow {
    param(
        [string]$PowerShellPath = "$PSHOME\powershell.exe"
    )
    
    try {
        Write-Log -Message "Initializing main window" -Level INFO -Component "GUI"
        $form = Initialize-MainWindow -PowerShellPath $PowerShellPath
        
        if ($null -eq $form) {
            throw "Failed to initialize main window"
        }
        
        Write-Log -Message "Showing main window" -Level INFO -Component "GUI"
        [void]$form.ShowDialog()
    }
    catch {
        Write-Log -Message "Error showing main window: $_" -Level ERROR -Component "GUI"
        throw
    }
}

# Helper function to update the status strip
function Update-Status {
    param([string]$Message)
    
    if ($null -ne $script:MainForm) {
        $statusLabel = $script:MainForm.Controls["StatusStrip"].Items["StatusLabel"]
        if ($null -ne $statusLabel) {
            $statusLabel.Text = $Message
        }
    }
}

# Helper function to enable/disable tabs based on analysis state
function Update-TabStates {
    param([bool]$AnalysisCompleted)
    
    if ($null -ne $script:MainForm) {
        $tabControl = $script:MainForm.Controls["MainTabControl"]
        if ($null -ne $tabControl) {
            $tabControl.TabPages["SearchTab"].Enabled = $AnalysisCompleted
            $tabControl.TabPages["ExtractTab"].Enabled = $AnalysisCompleted
        }
    }
}

--------------------

### File: C:\Users\OlavHeggelund\Documents\DiagLogAnalyserApp\DiagLogAnalyserApp\src\GUI\Panels.ps1 ###
. (Join-Path -Path $PSScriptRoot -ChildPath "Controls.ps1")
. (Join-Path -Path $PSScriptRoot -ChildPath "EventHandlers.ps1")
. (Join-Path -Path $PSScriptRoot -ChildPath "Helpers.ps1")

# Panel creation functions

function New-AnalysisPanel {
    $panel = New-Object System.Windows.Forms.Panel
    $panel.Dock = "Fill"
    $panel.Padding = New-Object System.Windows.Forms.Padding(10)

    # Source folder controls
    $panel.Controls.Add((New-SourcePathControls))

    # Analysis options
    $panel.Controls.Add((New-AnalysisOptionsGroup))

    # Action buttons
    $panel.Controls.Add((New-ActionButtonsGroup))

    # Results area
    $panel.Controls.Add((New-ResultsTextBox))

    return $panel
}

function New-SearchPanel {
    $panel = New-Object System.Windows.Forms.Panel
    $panel.Dock = "Fill"
    $panel.Padding = New-Object System.Windows.Forms.Padding(10)

    # Search controls
    $panel.Controls.Add((New-SearchControls))
    
    # File type filter
    $panel.Controls.Add((New-FileTypeFilter))
    
    # Results area
    $panel.Controls.Add((New-ResultsTextBox))

    return $panel
}

# ... Add other panel creation functions

--------------------

### File: C:\Users\OlavHeggelund\Documents\DiagLogAnalyserApp\DiagLogAnalyserApp\src\GUI\TabControls.ps1 ###
# Tab Controls Module

function New-TabControl {
    $tabControl = New-Object System.Windows.Forms.TabControl
    $tabControl.Dock = "Fill"
    $tabControl.Name = "MainTabControl"
    
    $tabControl.TabPages.AddRange(@(
        (New-AnalysisTab),
        (New-SearchTab),
        (New-ExtractTab),
        (New-SettingsTab),
        (New-AboutTab)
    ))
    
    return $tabControl
}

function New-AnalysisTab {
    $tab = New-Object System.Windows.Forms.TabPage
    $tab.Text = "Analysis"
    $tab.Name = "AnalysisTab"
    
    # Add controls
    $panel = New-AnalysisPanel
    $tab.Controls.Add($panel)
    
    return $tab
}

function New-SearchTab {
    $tab = New-Object System.Windows.Forms.TabPage
    $tab.Text = "Search"
    $tab.Name = "SearchTab"
    $tab.Enabled = $false
    
    # Add controls
    $panel = New-SearchPanel
    $tab.Controls.Add($panel)
    
    return $tab
}

# ... Continue with other tab creation functions

--------------------

### File: C:\Users\OlavHeggelund\Documents\DiagLogAnalyserApp\DiagLogAnalyserApp\src\Utils\FileSystem.psm1 ###
# DiagLog Analyzer - File System Utilities
# This module provides file system related functions

# Import dependencies
try {
    $loggingPath = Join-Path -Path $PSScriptRoot -ChildPath "Logging.psm1"
    if (Test-Path $loggingPath) {
        Import-Module $loggingPath -Force -ErrorAction Stop
    } else {
        throw "Logging module not found at: $loggingPath"
    }
} catch {
    Write-Error "Failed to import required module: $_"
    exit 1
}

function Test-CabFile {
    param (
        [Parameter(Mandatory=$true)]
        [string]$FilePath
    )
    
    # Check file extension first as a quick filter
    if (-not ($FilePath -match '\.cab$')) {
        return $false
    }
    
    try {
        # Read the first 8 bytes to check the CAB file signature
        $stream = [System.IO.File]::OpenRead($FilePath)
        $buffer = New-Object byte[] 8
        $bytesRead = $stream.Read($buffer, 0, 8)
        $stream.Close()
        
        # CAB file signature starts with "MSCF" (0x4D, 0x53, 0x43, 0x46)
        if ($buffer[0] -eq 0x4D -and $buffer[1] -eq 0x53 -and $buffer[2] -eq 0x43 -and $buffer[3] -eq 0x46) {
            return $true
        }
        
        return $false
    }
    catch {
        Write-Log -Message "Error checking if $FilePath is a CAB file: $_" -Level ERROR -Component "FileSystem"
        return $false
    }
}

function Format-FileSize {
    param (
        [Parameter(Mandatory=$true)]
        [long]$SizeInBytes
    )
    
    if ($SizeInBytes -lt 1KB) {
        return "$SizeInBytes B"
    }
    elseif ($SizeInBytes -lt 1MB) {
        return "{0:N2} KB" -f ($SizeInBytes / 1KB)
    }
    elseif ($SizeInBytes -lt 1GB) {
        return "{0:N2} MB" -f ($SizeInBytes / 1MB)
    }
    else {
        return "{0:N2} GB" -f ($SizeInBytes / 1GB)
    }
}

function Get-FileTempPath {
    param (
        [Parameter(Mandatory=$true)]
        [string]$OriginalFilePath,
        
        [string]$SubDir = ""
    )
    
    $fileName = [System.IO.Path]::GetFileName($OriginalFilePath)
    $tempDir = [System.IO.Path]::GetTempPath()
    
    if (-not [string]::IsNullOrEmpty($SubDir)) {
        $tempDir = Join-Path -Path $tempDir -ChildPath $SubDir
        if (-not (Test-Path -Path $tempDir)) {
            New-Item -Path $tempDir -ItemType Directory -Force | Out-Null
        }
    }
    
    return Join-Path -Path $tempDir -ChildPath $fileName
}

function Get-FileType {
    param (
        [Parameter(Mandatory=$true)]
        [string]$FilePath
    )
    
    try {
        $extension = [System.IO.Path]::GetExtension($FilePath).ToLower()
        
        # Handle no extension case
        if ([string]::IsNullOrEmpty($extension)) {
            # Try to determine type by examining file content
            $content = Get-Content -Path $FilePath -Raw -TotalCount 1KB -ErrorAction SilentlyContinue
            
            if ($null -eq $content) {
                return "binary"
            }
            
            # Check for common file signatures or patterns
            if ($content -match "^<\?xml") {
                return "xml"
            }
            elseif ($content -match "^<!DOCTYPE html" -or $content -match "<html") {
                return "html"
            }
            elseif ($content -match "^\{.*\}$" -or $content -match "^\[.*\]$") {
                return "json"
            }
            else {
                # Default to text if it contains mostly printable ASCII
                $printableCount = ($content -replace "[^\x20-\x7E]", "").Length
                if ($printableCount / $content.Length -gt 0.8) {
                    return "text"
                }
                else {
                    return "binary"
                }
            }
        }
        
        # Known extensions
        $textExtensions = @(".txt", ".log", ".xml", ".html", ".htm", ".json", ".csv", ".ps1", ".psm1", ".psd1", ".cfg", ".config", ".ini")
        $imageExtensions = @(".jpg", ".jpeg", ".png", ".gif", ".bmp", ".tiff", ".ico")
        $archiveExtensions = @(".zip", ".rar", ".7z", ".cab", ".tar", ".gz", ".tgz")
        
        if ($textExtensions -contains $extension) {
            return "text"
        }
        elseif ($imageExtensions -contains $extension) {
            return "image"
        }
        elseif ($archiveExtensions -contains $extension) {
            return "archive"
        }
        elseif ($extension -eq ".exe" -or $extension -eq ".dll") {
            return "executable"
        }
        else {
            # For unknown extensions, try to determine if it's text or binary
            try {
                $content = Get-Content -Path $FilePath -Raw -TotalCount 1KB -ErrorAction Stop
                
                # Check if the content is mostly printable ASCII
                $printableCount = ($content -replace "[^\x20-\x7E]", "").Length
                if ($printableCount / $content.Length -gt 0.8) {
                    return "text"
                }
                else {
                    return "binary"
                }
            }
            catch {
                return "binary"
            }
        }
    }
    catch {
        Write-Log -Message "Error determining file type for $FilePath : $_" -Level ERROR -Component "FileSystem"
        return "unknown"
    }
}

function Get-SafeFilePath {
    param (
        [Parameter(Mandatory=$true)]
        [string]$FilePath,
        
        [int]$MaxLength = 260
    )
    
    if ($FilePath.Length -le $MaxLength) {
        return $FilePath
    }
    
    # Shorten path while preserving filename
    $dirName = [System.IO.Path]::GetDirectoryName($FilePath)
    $fileName = [System.IO.Path]::GetFileName($FilePath)
    
    # Calculate available space for directory
    $availableLength = $MaxLength - $fileName.Length - 1  # -1 for path separator
    
    if ($availableLength -le 0) {
        # Filename itself is too long, truncate it
        $extension = [System.IO.Path]::GetExtension($FilePath)
        $baseFileName = [System.IO.Path]::GetFileNameWithoutExtension($FilePath)
        $maxBaseLength = $MaxLength - $extension.Length - 3  # -3 for "..." 
        $truncatedFileName = $baseFileName.Substring(0, $maxBaseLength) + "..." + $extension
        
        return Join-Path -Path $dirName -ChildPath $truncatedFileName
    }
    else {
        # Truncate directory part
        $truncatedDir = $dirName.Substring(0, $availableLength - 3) + "..."
        return Join-Path -Path $truncatedDir -ChildPath $fileName
    }
}

--------------------

### File: C:\Users\OlavHeggelund\Documents\DiagLogAnalyserApp\DiagLogAnalyserApp\src\Utils\Logging.psm1 ###
# DiagLog Analyzer - Logging Utility
# This module provides logging functionality for the application

# Import settings module
$settingsModule = Join-Path -Path $PSScriptRoot -ChildPath "..\Config\Settings.psm1"
Import-Module $settingsModule -Force

# Script variables
$script:LogInitialized = $false
$script:LogFile = $null
$script:LogLevel = @{
    DEBUG = 0
    INFO = 1
    WARNING = 2
    ERROR = 3
}

function Initialize-DLALogging {
    [CmdletBinding()]
    param()
    
    try {
        $logPath = Get-DLASetting -Name "LogPath"
        $logDir = Split-Path -Parent $logPath
        
        if (-not (Test-Path $logDir)) {
            New-Item -Path $logDir -ItemType Directory -Force | Out-Null
        }
        
        $script:LogFile = $logPath
        $script:LogInitialized = $true
        
        Write-Verbose "Logging initialized to: $logPath"
        return $true
    }
    catch {
        Write-Error "Failed to initialize logging: $_"
        return $false
    }
}

function Write-DLALog {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory=$true)]
        [string]$Message,
        
        [Parameter()]
        [ValidateSet('DEBUG', 'INFO', 'WARNING', 'ERROR')]
        [string]$Level = 'INFO',
        
        [Parameter()]
        [string]$Component = 'General',
        
        [Parameter()]
        [System.Management.Automation.ErrorRecord]$ErrorRecord,
        
        [Parameter()]
        [switch]$NoWrite
    )
    
    if (-not $script:LogInitialized) {
        Initialize-DLALogging
    }
    
    $timestamp = Get-Date -Format "yyyy-MM-dd HH:mm:ss"
    $logEntry = "$timestamp [$Level] [$Component] $Message"
    
    # Add to log file
    $logEntry | Add-Content -Path $script:LogFile -Encoding UTF8
    
    # Output to console with appropriate stream
    if (-not $NoWrite) {
        switch ($Level) {
            'ERROR' { 
                Write-Error $logEntry
                if ($ErrorRecord) {
                    Write-Error $ErrorRecord
                }
            }
            'WARNING' { Write-Warning $logEntry }
            'INFO' { Write-Verbose $logEntry -Verbose }
            'DEBUG' { Write-Debug $logEntry }
        }
    }
    
    # If there's an error record, log the stack trace
    if ($ErrorRecord) {
        $stackTrace = $ErrorRecord.ScriptStackTrace
        if (-not [string]::IsNullOrEmpty($stackTrace)) {
            $stackEntry = "$timestamp [$Level] [$Component] $stackTrace"
            $stackEntry | Add-Content -Path $script:LogFile -Encoding UTF8
            
            if (-not $NoWrite) {
                Write-Error $stackTrace
            }
        }
    }
}

function Get-DLALogFile {
    return $script:LogFile
}

function Clear-DLALog {
    if (Test-Path $script:LogFile) {
        Clear-Content -Path $script:LogFile
        Write-DLALog -Message "Log file cleared" -Level INFO -NoWrite
    }
}

# Convenience functions for different log levels
function Write-DLADebug { param([string]$Message) Write-DLALog -Message $Message -Level DEBUG }
function Write-DLAInfo { param([string]$Message) Write-DLALog -Message $Message -Level INFO }
function Write-DLAWarning { param([string]$Message) Write-DLALog -Message $Message -Level WARNING }
function Write-DLAError { 
    param(
        [string]$Message,
        [System.Management.Automation.ErrorRecord]$ErrorRecord
    ) 
    Write-DLALog -Message $Message -Level ERROR -ErrorRecord $ErrorRecord
}

Export-ModuleMember -Function Initialize-DLALogging, 
                            Write-DLALog,
                            Write-DLADebug,
                            Write-DLAInfo,
                            Write-DLAWarning,
                            Write-DLAError,
                            Get-DLALogFile,
                            Clear-DLALog

--------------------

### File: C:\Users\OlavHeggelund\Documents\DiagLogAnalyserApp\DiagLogAnalyserApp\src\Utils\Reporting.ps1 ###
# DiagLog Analyzer - Reporting Module
# This module handles generation of HTML reports

# Import dependencies
. (Join-Path -Path $PSScriptRoot -ChildPath "Logging.ps1")
. (Join-Path -Path $PSScriptRoot -ChildPath "FileSystem.ps1")
. (Join-Path -Path $PSScriptRoot -ChildPath "..\Core\FileSearch.ps1")

function New-AnalysisReport {
    param (
        [Parameter(Mandatory=$true)]
        [hashtable]$AnalysisResults,
        
        [Parameter(Mandatory=$false)]
        [string]$OutputPath = $null
    )
    
    if ([string]::IsNullOrEmpty($OutputPath)) {
        $timestamp = Get-Date -Format "yyyyMMdd-HHmmss"
        $OutputPath = Join-Path -Path (Get-AppSetting -Name "DefaultOutputPath") -ChildPath "AnalysisReport-$timestamp.html"
    }
    
    Write-Log -Message "Generating analysis report: $OutputPath" -Level INFO -Component "Reporting"
    
    # Create HTML header with styles
    $htmlHeader = @"
<!DOCTYPE html>
<html>
<head>
    <title>DiagLog Analysis Report</title>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; color: #333; line-height: 1.6; }
        h1 { color: #0066cc; border-bottom: 1px solid #eee; padding-bottom: 10px; }
        h2 { color: #0066cc; margin-top: 30px; border-bottom: 1px solid #eee; padding-bottom: 5px; }
        h3 { color: #0066cc; }
        .summary { background-color: #f8f9fa; padding: 15px; margin-bottom: 20px; border-radius: 5px; border-left: 4px solid #0066cc; }
        table { width: 100%; border-collapse: collapse; margin-bottom: 20px; }
        th { background-color: #0066cc; color: white; text-align: left; padding: 8px; position: sticky; top: 0; }
        td { padding: 8px; border-bottom: 1px solid #ddd; }
        tr:nth-child(even) { background-color: #f2f2f2; }
        tr:hover { background-color: #e6f2ff; }
        .scrollable { max-height: 600px; overflow-y: auto; margin-bottom: 30px; }
        .filter-container { margin-bottom: 20px; }
        .filter-container label { margin-right: 10px; }
        .chart-container { height: 400px; margin-bottom: 40px; }
        .flex-container { display: flex; flex-wrap: wrap; gap: 20px; }
        .flex-item { flex: 1; min-width: 300px; }
        .timestamp { color: #666; font-size: 0.9em; }
        .pill { display: inline-block; padding: 2px 8px; border-radius: 12px; font-size: 0.85em; font-weight: bold; }
        .pill-text { background-color: #c3e6cb; color: #155724; }
        .pill-binary { background-color: #f5c6cb; color: #721c24; }
        .pill-archive { background-color: #bee5eb; color: #0c5460; }
        .pill-image { background-color: #ffeeba; color: #856404; }
        .pill-other { background-color: #d6d8db; color: #383d41; }
        
        /* Add responsive design */
        @media (max-width: 768px) {
            .flex-item { min-width: 100%; }
        }
    </style>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script>
        function filterTable(tableId) {
            var input = document.getElementById(tableId + 'Filter');
            var table = document.getElementById(tableId);
            var filter = input.value.toUpperCase();
            var rows = table.getElementsByTagName('tr');
            
            for (var i = 1; i < rows.length; i++) {
                var visible = false;
                var cells = rows[i].getElementsByTagName('td');
                for (var j = 0; j < cells.length; j++) {
                    var cell = cells[j];
                    if (cell) {
                        if (cell.textContent.toUpperCase().indexOf(filter) > -1) {
                            visible = true;
                            break;
                        }
                    }
                }
                rows[i].style.display = visible ? '' : 'none';
            }
        }
    </script>
</head>
<body>
    <h1>DiagLog Analysis Report</h1>
    <p class="timestamp">Generated: $(Get-Date -Format "yyyy-MM-dd HH:mm:ss")</p>
"@
    
    # Create summary section
    $htmlSummary = @"
    <div class="summary">
        <h2>Analysis Summary</h2>
        <p><strong>Source Path:</strong> $($AnalysisResults.SourcePath)</p>
        <p><strong>Analysis Time:</strong> $($AnalysisResults.AnalysisTime)</p>
        <p><strong>Total Items:</strong> $($AnalysisResults.TotalItems)</p>
        <p><strong>Files:</strong> $($AnalysisResults.Files)</p>
        <p><strong>Directories:</strong> $($AnalysisResults.Directories)</p>
        <p><strong>Total Size:</strong> $(Format-FileSize -SizeInBytes $AnalysisResults.TotalSize)</p>
        <p><strong>Directory Depth:</strong> $($AnalysisResults.DirectoryDepth)</p>
        <p><strong>CAB Files:</strong> $($AnalysisResults.CabFiles.Count)</p>
    </div>
    
    <div class="flex-container">
        <div class="flex-item">
            <h2>File Type Distribution</h2>
            <canvas id="fileTypeChart"></canvas>
        </div>
        <div class="flex-item">
            <h2>File Size Distribution</h2>
            <canvas id="fileSizeChart"></canvas>
        </div>
    </div>
"@
    
    # Create extensions section
    $htmlExtensions = @"
    <h2>File Extensions</h2>
    <div class="filter-container">
        <label for="extensionsTableFilter">Filter:</label>
        <input type="text" id="extensionsTableFilter" onkeyup="filterTable('extensionsTable')" placeholder="Search for extensions...">
    </div>
    <div class="scrollable">
        <table id="extensionsTable">
            <tr>
                <th>Extension</th>
                <th>Count</th>
                <th>Total Size</th>
                <th>Average Size</th>
                <th>Type</th>
            </tr>
"@
    
    # Add extension rows
    foreach ($ext in $AnalysisResults.Extensions.GetEnumerator() | Sort-Object -Property {$_.Value.Count} -Descending) {
        $extension = $ext.Key
        $stats = $ext.Value
        $avgSize = if ($stats.Count -gt 0) { $stats.TotalSize / $stats.Count } else { 0 }
        
        # Determine type for the extension
        $fileType = "text"
        if ($stats.SampleFiles.Count -gt 0) {
            $fileType = Get-FileType -FilePath $stats.SampleFiles[0]
        }
        
        $typeClass = "pill-other"
        switch ($fileType) {
            "text" { $typeClass = "pill-text" }
            "binary" { $typeClass = "pill-binary" }
            "archive" { $typeClass = "pill-archive" }
            "image" { $typeClass = "pill-image" }
        }
        
        $htmlExtensions += @"
            <tr>
                <td>$extension</td>
                <td>$($stats.Count)</td>
                <td>$(Format-FileSize -SizeInBytes $stats.TotalSize)</td>
                <td>$(Format-FileSize -SizeInBytes $avgSize)</td>
                <td><span class="pill $typeClass">$fileType</span></td>
            </tr>
"@
    }
    
    $htmlExtensions += @"
        </table>
    </div>
"@
    
    # Create CAB files section
    $htmlCabFiles = @"
    <h2>CAB Files</h2>
"@
    
    if ($AnalysisResults.CabFiles.Count -gt 0) {
        $htmlCabFiles += @"
    <div class="filter-container">
        <label for="cabTableFilter">Filter:</label>
        <input type="text" id="cabTableFilter" onkeyup="filterTable('cabTable')" placeholder="Search for CAB files...">
    </div>
    <div class="scrollable">
        <table id="cabTable">
            <tr>
                <th>File</th>
                <th>Size</th>
                <th>Extracted</th>
                <th>Extraction Path</th>
            </tr>
"@
        
        foreach ($cab in $AnalysisResults.CabFiles) {
            $htmlCabFiles += @"
            <tr>
                <td>$($cab.RelativePath)</td>
                <td>$(Format-FileSize -SizeInBytes $cab.Size)</td>
                <td>$($cab.Processed -and $cab.ExtractionSuccess)</td>
                <td>$($cab.ExtractedPath)</td>
            </tr>
"@
        }
        
        $htmlCabFiles += @"
        </table>
    </div>
"@
    }
    else {
        $htmlCabFiles += @"
    <p>No CAB files found in the analyzed directory.</p>
"@
    }
    
    # Create largest files section
    $htmlLargestFiles = @"
    <h2>Largest Files</h2>
    <div class="scrollable">
        <table id="largeFilesTable">
            <tr>
                <th>File</th>
                <th>Size</th>
                <th>Type</th>
            </tr>
"@
    
    foreach ($file in $AnalysisResults.LargestFiles | Select-Object -First 20) {
        $relPath = $file.Path.Substring($AnalysisResults.SourcePath.Length + 1)
        $typeClass = "pill-other"
        switch ($file.Type) {
            "text" { $typeClass = "pill-text" }
            "binary" { $typeClass = "pill-binary" }
            "archive" { $typeClass = "pill-archive" }
            "image" { $typeClass = "pill-image" }
        }
        
        $htmlLargestFiles += @"
            <tr>
                <td>$relPath</td>
                <td>$(Format-FileSize -SizeInBytes $file.Size)</td>
                <td><span class="pill $typeClass">$($file.Type)</span></td>
            </tr>
"@
    }
    
    $htmlLargestFiles += @"
        </table>
    </div>
"@
    
    # Create JavaScript for charts
    $htmlCharts = @"
    <script>
        // File type distribution chart
        var fileTypeChartCtx = document.getElementById('fileTypeChart').getContext('2d');
        var fileTypeData = {
            labels: $(($AnalysisResults.FileTypes.Keys | ConvertTo-Json)),
            datasets: [{
                data: $(($AnalysisResults.FileTypes.Values | ForEach-Object { $_.Count } | ConvertTo-Json)),
                backgroundColor: [
                    'rgba(54, 162, 235, 0.7)',
                    'rgba(255, 99, 132, 0.7)',
                    'rgba(255, 206, 86, 0.7)',
                    'rgba(75, 192, 192, 0.7)',
                    'rgba(153, 102, 255, 0.7)'
                ]
            }]
        };
        var fileTypeChart = new Chart(fileTypeChartCtx, {
            type: 'doughnut',
            data: fileTypeData,
            options: {
                responsive: true,
                maintainAspectRatio: true,
                plugins: {
                    legend: {
                        position: 'right'
                    },
                    title: {
                        display: true,
                        text: 'File Types'
                    }
                }
            }
        });
        
        // File size distribution chart (top extensions by size)
        var fileSizeChartCtx = document.getElementById('fileSizeChart').getContext('2d');
        var extensionsBySize = $(
            ($AnalysisResults.Extensions.GetEnumerator() | 
            Sort-Object -Property {$_.Value.TotalSize} -Descending | 
            Select-Object -First 10 | 
            ForEach-Object { 
                [PSCustomObject]@{ 
                    Extension = $_.Key
                    Size = $_.Value.TotalSize
                } 
            } | ConvertTo-Json)
        );
        
        var fileSizeData = {
            labels: extensionsBySize.map(item => item.Extension),
            datasets: [{
                label: 'Total Size',
                data: extensionsBySize.map(item => item.Size),
                backgroundColor: 'rgba(54, 162, 235, 0.7)',
                borderColor: 'rgba(54, 162, 235, 1)',
                borderWidth: 1
            }]
        };
        
        var fileSizeChart = new Chart(fileSizeChartCtx, {
            type: 'bar',
            data: fileSizeData,
            options: {
                responsive: true,
                maintainAspectRatio: true,
                scales: {
                    y: {
                        beginAtZero: true,
                        ticks: {
                            // Format byte values
                            callback: function(value) {
                                const units = ['B', 'KB', 'MB', 'GB', 'TB'];
                                let unitIndex = 0;
                                let scaledValue = value;
                                
                                while (scaledValue >= 1024 && unitIndex < units.length - 1) {
                                    unitIndex++;
                                    scaledValue /= 1024;
                                }
                                
                                return scaledValue.toFixed(2) + ' ' + units[unitIndex];
                            }
                        }
                    }
                },
                plugins: {
                    title: {
                        display: true,
                        text: 'Top 10 Extensions by Size'
                    }
                }
            }
        });
    </script>
"@
    
    # Create HTML footer
    $htmlFooter = @"
</body>
</html>
"@
    
    # Combine all HTML parts
    $htmlReport = $htmlHeader + $htmlSummary + $htmlExtensions + $htmlCabFiles + $htmlLargestFiles + $htmlCharts + $htmlFooter
    
    # Save the HTML report
    $htmlReport | Out-File -FilePath $OutputPath -Encoding utf8
    
    Write-Log -Message "Analysis report saved to $OutputPath" -Level INFO -Component "Reporting"
    
    return $OutputPath
}

function New-SearchReport {
    param (
        [Parameter(Mandatory=$true)]
        [PSCustomObject]$SearchResults,
        
        [Parameter(Mandatory=$false)]
        [string]$OutputPath = $null,
        
        [switch]$HighlightMatches = $true
    )
    
    if ([string]::IsNullOrEmpty($OutputPath)) {
        $timestamp = Get-Date -Format "yyyyMMdd-HHmmss"
        $OutputPath = Join-Path -Path (Get-AppSetting -Name "DefaultOutputPath") -ChildPath "SearchReport-$timestamp.html"
    }
    
    Write-Log -Message "Generating search report: $OutputPath" -Level INFO -Component "Reporting"
    
    # Create HTML header with styles
    $htmlHeader = @"
<!DOCTYPE html>
<html>
<head>
    <title>DiagLog Search Results</title>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; color: #333; line-height: 1.6; }
        h1 { color: #0066cc; border-bottom: 1px solid #eee; padding-bottom: 10px; }
        h2 { color: #0066cc; margin-top: 30px; border-bottom: 1px solid #eee; padding-bottom: 5px; }
        h3 { color: #0066cc; }
        .summary { background-color: #f8f9fa; padding: 15px; margin-bottom: 20px; border-radius: 5px; border-left: 4px solid #0066cc; }
        .file-result { background-color: #f8f9fa; padding: 15px; margin-bottom: 20px; border-radius: 5px; }
        .match-context { background-color: white; padding: 10px; margin: 10px 0; border-radius: 3px; border: 1px solid #ddd; }
        .match-line { background-color: #FFEB3B; padding: 2px; }
        .line-number { color: #999; margin-right: 10px; user-select: none; }
        pre { margin: 0; font-family: Consolas, monospace; white-space: pre-wrap; }
        .highlight { background-color: #FFEB3B; font-weight: bold; }
        .filter-container { margin-bottom: 20px; }
        .filter-input { padding: 8px; width: 300px; }
        .timestamp { color: #666; font-size: 0.9em; }
        .file-path { word-break: break-all; }
        
        /* Collapsible sections */
        .collapsible { cursor: pointer; }
        .content { display: none; overflow: hidden; }
        .active { display: block; }
        
/* Responsive design */
        @media (max-width: 768px) {
            .filter-input { width: 100%; }
        }
    </style>
    <script>
        function filterResults() {
            var input = document.getElementById('resultsFilter');
            var filter = input.value.toUpperCase();
            var fileResults = document.getElementsByClassName('file-result');
            
            for (var i = 0; i < fileResults.length; i++) {
                var fileResult = fileResults[i];
                var fileContent = fileResult.textContent || fileResult.innerText;
                
                if (fileContent.toUpperCase().indexOf(filter) > -1) {
                    fileResult.style.display = '';
                } else {
                    fileResult.style.display = 'none';
                }
            }
        }
        
        function toggleCollapsible(element) {
            var content = element.nextElementSibling;
            content.classList.toggle('active');
        }
        
        function expandAll() {
            var contents = document.getElementsByClassName('content');
            for (var i = 0; i < contents.length; i++) {
                contents[i].classList.add('active');
            }
        }
        
        function collapseAll() {
            var contents = document.getElementsByClassName('content');
            for (var i = 0; i < contents.length; i++) {
                contents[i].classList.remove('active');
            }
        }
    </script>
</head>
<body>
    <h1>DiagLog Search Results</h1>
    <p class="timestamp">Generated: $(Get-Date -Format "yyyy-MM-dd HH:mm:ss")</p>
"@
    
    # Create summary section
    $htmlSummary = @"
    <div class="summary">
        <h2>Search Summary</h2>
        <p><strong>Search Text:</strong> $($SearchResults.SearchText)</p>
        <p><strong>Total Files Processed:</strong> $($SearchResults.FilesProcessed)</p>
        <p><strong>Files With Matches:</strong> $($SearchResults.FilesWithMatches)</p>
        <p><strong>Files Skipped:</strong> $($SearchResults.FilesSkipped)</p>
        <p><strong>Total Matches:</strong> $($SearchResults.TotalMatches)</p>
    </div>
    
    <div class="filter-container">
        <input type="text" id="resultsFilter" onkeyup="filterResults()" class="filter-input" placeholder="Filter results...">
        <button onclick="expandAll()">Expand All</button>
        <button onclick="collapseAll()">Collapse All</button>
    </div>
"@
    
    # Create results section
    $htmlResults = ""
    
    $matchingResults = $SearchResults.Results | Where-Object { -not $_.Skipped -and $_.MatchCount -gt 0 } | Sort-Object -Property MatchCount -Descending
    
    foreach ($fileResult in $matchingResults) {
        $relativePath = $fileResult.FilePath
        
        $htmlResults += @"
    <div class="file-result">
        <h3 class="collapsible" onclick="toggleCollapsible(this)">$($relativePath) ($($fileResult.MatchCount) matches)</h3>
        <div class="content">
"@
        
        foreach ($match in $fileResult.Matches) {
            $htmlResults += @"
            <div class="match-context">
                <p>Line $($match.MatchLineNumber):</p>
"@
            
            # Add context lines before match
            foreach ($line in $match.BeforeContext) {
                $htmlResults += @"
                <pre><span class="line-number">$($line.LineNumber)</span>$($line.Text)</pre>
"@
            }
            
            # Add the matching line with highlighting
            $matchText = $match.MatchLine
            if ($HighlightMatches) {
                $matchText = Highlight-SearchText -Text $match.MatchLine -SearchText $SearchResults.SearchText
            }
            
            $htmlResults += @"
                <pre class="match-line"><span class="line-number">$($match.MatchLineNumber)</span>$matchText</pre>
"@
            
            # Add context lines after match
            foreach ($line in $match.AfterContext) {
                $htmlResults += @"
                <pre><span class="line-number">$($line.LineNumber)</span>$($line.Text)</pre>
"@
            }
            
            $htmlResults += @"
            </div>
"@
